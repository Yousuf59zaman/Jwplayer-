<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JW Player Test - HLS Fallback</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .instructions {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .instructions h2 {
            margin-top: 0;
            color: #FF6C00;
        }
        .instructions code {
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .instructions pre {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        #player-container {
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            min-height: 360px;
        }
        .controls {
            margin-top: 20px;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #FF6C00;
            padding-bottom: 10px;
        }
        .control-group {
            margin: 15px 0;
        }
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #555;
        }
        .controls button {
            background-color: #FF6C00;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .controls button:hover {
            background-color: #e66100;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .controls button.active {
            background-color: #009688;
            box-shadow: 0 0 10px rgba(0,150,136,0.5);
        }
        .control-group select {
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #ddd;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
        }
        .control-group select:hover {
            border-color: #FF6C00;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
    <!-- Load the JW Player library from the debug build -->
    <script src="bin-debug/jwplayer.js"></script>
    <!-- HLS.js fallback for browsers that lack native HLS (Chrome/Edge/Firefox on Windows) -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.15/dist/hls.min.js"></script>
</head>
<body>
    <h1>JW Player Test - HLS Enabled</h1>

    <div class="instructions">
        <h2>What changed?</h2>
        <ul>
            <li>Added an <code>hls.js</code> fallback so the m3u8 plays on desktop browsers without native HLS.</li>
            <li>Quality dropdown is rebuilt dynamically; “Auto” appears when hls.js is in use.</li>
            <li>Cleaned control labels and playback rate toggles now keep the active state.</li>
        </ul>
        <p><strong>To test another stream, replace the <code>HLS_SOURCE.file</code> URL in the script.</strong></p>
        <pre>sources: [
    { file: 'https://example.com/path/to/index.m3u8', label: 'HLS', type: 'm3u8', default: true }
]</pre>
    </div>

    <!-- Player Container -->
    <div id="player-container">Loading the player...</div>

    <div class="controls">
        <h3>Playback Speed Controls</h3>
        <div class="control-group">
            <label>Select Speed:</label>
            <button class="speed-btn" onclick="setSpeed(0.25, event)">0.25x</button>
            <button class="speed-btn" onclick="setSpeed(0.5, event)">0.5x</button>
            <button class="speed-btn" onclick="setSpeed(0.75, event)">0.75x</button>
            <button class="speed-btn active" id="speed-1" onclick="setSpeed(1, event)">1x (Normal)</button>
            <button class="speed-btn" onclick="setSpeed(1.25, event)">1.25x</button>
            <button class="speed-btn" onclick="setSpeed(1.5, event)">1.5x</button>
            <button class="speed-btn" onclick="setSpeed(2, event)">2x</button>
            <button class="speed-btn" onclick="setSpeed(3, event)">3x</button>
        </div>
        <div class="status" id="speed-status">Current Speed: 1x</div>

        <h3>Quality Controls</h3>
        <div class="control-group">
            <label>Select Quality Level:</label>
            <select id="quality-selector" onchange="changeQuality()"></select>
        </div>
        <div class="status" id="quality-status">Current Quality: Loading...</div>

        <h3>Basic Player Controls</h3>
        <div class="control-group">
            <button onclick="player.play()">Play</button>
            <button onclick="player.pause()">Pause</button>
            <button onclick="player.setVolume(Math.min(100, player.getVolume() + 10))">Volume +</button>
            <button onclick="player.setVolume(Math.max(0, player.getVolume() - 10))">Volume -</button>
            <button onclick="player.seek(0)">Restart</button>
            <button onclick="showInfo()">Info</button>
        </div>
    </div>

    <script>
        const HLS_SOURCE = {
            file: 'https://eu2.contabostorage.com/beede22b78b34cd7b1c01987a4332d1b:meteka/111/index.m3u8',
            label: 'HLS Test Stream',
            type: 'm3u8',
            default: true
        };
        const AUTO_QUALITY = 'auto';
        let player;
        let usingHlsJsFallback = false;

        /**
         * Detect if the current browser can play HLS natively.
         * Limit this to Safari/iOS where HLS is genuinely supported natively.
         */
        function browserCanPlayHlsNatively() {
            const testVideo = document.createElement('video');
            if (!testVideo.canPlayType) {
                return false;
            }

            const ua = navigator.userAgent || '';
            const isIOS = /iP(ad|hone|od)/i.test(ua);
            const isSafari = /Safari/i.test(ua) && !/Chrome|Chromium|Edg/i.test(ua);
            const canPlay = testVideo.canPlayType('application/vnd.apple.mpegurl');

            return (isIOS || isSafari) && !!canPlay;
        }

        /**
         * Build a test player. If native HLS is missing, fall back to hls.js + HTML5 video
         * so the m3u8 can play on desktop Chrome/Edge/Firefox.
         */
        function initPlayer() {
            // Prefer hls.js when available (Chrome/Edge/Firefox). Use native only on Safari/iOS.
            if (window.Hls && Hls.isSupported()) {
                player = setupHlsJsFallback(HLS_SOURCE.file);
                usingHlsJsFallback = true;
                return;
            }

            if (browserCanPlayHlsNatively()) {
                player = setupJwPlayer(HLS_SOURCE);
                usingHlsJsFallback = false;
                return;
            }

            const container = document.getElementById('player-container');
            container.innerHTML = '<div style="padding:16px;color:#fff;">HLS is not supported in this browser and hls.js could not be loaded.</div>';
            throw new Error('No HLS support available');
        }

        /**
         * Standard JW Player setup (used when browser has native HLS).
         */
        function setupJwPlayer(source) {
            const instance = jwplayer('player-container').setup({
                sources: [source],
                width: '100%',
                aspectratio: '16:9',
                autostart: false,
                controls: true,
                mute: false,
                playbackRateControls: true
            });

            wireCommonListeners(instance);
            return instance;
        }

        /**
         * Lightweight player facade that wraps hls.js + a native video element
         * to mimic the JW API calls used by the page.
         */
        function setupHlsJsFallback(sourceUrl) {
            const container = document.getElementById('player-container');
            container.innerHTML = '<video id="hls-fallback" controls playsinline style="width:100%;height:100%;background:#000;"></video>';

            const video = document.getElementById('hls-fallback');
            const hls = new Hls({ enableWorker: true });
            const listeners = {};

            function emit(eventName, payload = {}) {
                (listeners[eventName] || []).forEach(cb => cb(payload));
            }

            const api = {
                play: () => video.play(),
                pause: () => video.pause(),
                setVolume: value => {
                    const clamped = Math.max(0, Math.min(100, value));
                    video.volume = clamped / 100;
                },
                getVolume: () => Math.round((video.volume ?? 1) * 100),
                seek: seconds => {
                    if (!Number.isNaN(seconds)) {
                        video.currentTime = seconds;
                    }
                },
                getPosition: () => video.currentTime || 0,
                getDuration: () => video.duration || 0,
                setPlaybackRate: rate => {
                    video.playbackRate = rate;
                    emit('playbackRateChanged', { playbackRate: video.playbackRate });
                },
                getPlaybackRate: () => video.playbackRate || 1,
                getQualityLevels: () => {
                    const levels = hls.levels || [];
                    return levels.map((level, index) => {
                        const pieces = [];
                        if (level.height) {
                            pieces.push(`${level.height}p`);
                        }
                        if (level.bitrate) {
                            pieces.push(`${Math.round(level.bitrate / 1000)}kbps`);
                        }
                        return {
                            label: pieces.join(' ') || `Level ${index + 1}`
                        };
                    });
                },
                getCurrentQuality: () => hls.autoLevelEnabled ? AUTO_QUALITY : hls.currentLevel,
                setCurrentQuality: quality => {
                    if (quality === AUTO_QUALITY || quality === -1) {
                        hls.currentLevel = -1;
                        hls.autoLevelEnabled = true;
                        emit('levelsChanged', { currentQuality: AUTO_QUALITY });
                        return;
                    }

                    const index = Number(quality);
                    if (!Number.isNaN(index)) {
                        hls.autoLevelEnabled = false;
                        hls.currentLevel = index;
                        emit('levelsChanged', { currentQuality: index });
                    }
                },
                on: (eventName, callback) => {
                    listeners[eventName] = listeners[eventName] || [];
                    listeners[eventName].push(callback);
                }
            };

            hls.loadSource(sourceUrl);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, () => emit('ready'));
            hls.on(Hls.Events.LEVEL_SWITCHED, (_, data) => emit('levelsChanged', { currentQuality: data.level }));
            hls.on(Hls.Events.ERROR, (_, data) => {
                emit('error', { message: data?.details || data?.reason || 'HLS.js error' });
            });

            video.addEventListener('play', () => emit('play'));
            video.addEventListener('pause', () => emit('pause'));
            video.addEventListener('ended', () => emit('complete'));
            video.addEventListener('ratechange', () => emit('playbackRateChanged', { playbackRate: video.playbackRate || 1 }));
            video.addEventListener('loadedmetadata', () => emit('ready'));
            video.addEventListener('error', () => emit('error', { message: video.error?.message || 'Playback error' }));

            wireCommonListeners(api);
            return api;
        }

        /**
         * Attach handlers that keep the page UI in sync with the current player
         * implementation (JW or the hls.js fallback).
         */
        function wireCommonListeners(playerInstance) {
            playerInstance.on('ready', handleReady);
            playerInstance.on('play', () => console.log('Video started playing'));
            playerInstance.on('pause', () => console.log('Video paused'));
            playerInstance.on('complete', () => console.log('Video completed'));
            playerInstance.on('error', handleError);
            playerInstance.on('playbackRateChanged', event => {
                document.getElementById('speed-status').textContent = `Current Speed: ${event.playbackRate}x`;
            });
            playerInstance.on('levelsChanged', handleLevelsChanged);
        }

        function handleReady() {
            console.log('Player is ready!');
            const qualities = player.getQualityLevels ? player.getQualityLevels() : [];
            const currentQuality = normalizeQuality(player.getCurrentQuality ? player.getCurrentQuality() : AUTO_QUALITY);
            populateQualitySelector(qualities, currentQuality);
            updateQualityStatus(qualities, currentQuality);
        }

        function handleLevelsChanged(event) {
            const qualities = player.getQualityLevels ? player.getQualityLevels() : [];
            const currentQuality = normalizeQuality(event?.currentQuality);
            updateQualityStatus(qualities, currentQuality);
        }

        function handleError(event) {
            console.error('Player error:', event);
            alert('Error loading video: ' + (event?.message || 'Unknown error'));
        }

        function populateQualitySelector(qualities, currentQuality) {
            const select = document.getElementById('quality-selector');
            select.innerHTML = '';

            if (usingHlsJsFallback) {
                const autoOption = document.createElement('option');
                autoOption.value = AUTO_QUALITY;
                autoOption.textContent = 'Auto (Default)';
                select.appendChild(autoOption);
            }

            qualities.forEach((quality, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = quality.label || `Level ${index + 1}`;
                select.appendChild(option);
            });

            const selectedValue = currentQuality === AUTO_QUALITY ? AUTO_QUALITY : String(currentQuality);
            if (Array.from(select.options).some(option => option.value === selectedValue)) {
                select.value = selectedValue;
            } else if (select.options.length) {
                select.selectedIndex = 0;
            }
        }

        function updateQualityStatus(qualities, currentQuality) {
            const label = currentQuality === AUTO_QUALITY
                ? 'Auto'
                : (qualities[currentQuality]?.label || `Level ${Number(currentQuality) + 1}`);
            document.getElementById('quality-status').textContent = `Current Quality: ${label}`;
        }

        function normalizeQuality(value) {
            if (value === AUTO_QUALITY || value === -1 || value === undefined || value === null) {
                return AUTO_QUALITY;
            }
            return value;
        }

        // Playback speed control
        function setSpeed(rate, evt) {
            try {
                player.setPlaybackRate(rate);
                document.getElementById('speed-status').textContent = `Current Speed: ${rate}x`;

                document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
                if (evt && evt.target) {
                    evt.target.classList.add('active');
                }

                console.log(`Playback speed set to ${rate}x`);
            } catch (error) {
                console.error('Error setting playback rate:', error);
                alert('Could not set playback speed. Make sure video is playing.');
            }
        }

        // Quality level control
        function changeQuality() {
            const select = document.getElementById('quality-selector');
            const selected = select.value;

            try {
                if (selected === AUTO_QUALITY && !usingHlsJsFallback) {
                    // JW Player does not expose an explicit "auto" index, so just keep current level
                    updateQualityStatus(player.getQualityLevels(), normalizeQuality(player.getCurrentQuality()));
                    return;
                }

                const qualityValue = selected === AUTO_QUALITY ? AUTO_QUALITY : parseInt(selected, 10);
                player.setCurrentQuality(qualityValue);

                const qualities = player.getQualityLevels();
                updateQualityStatus(qualities, normalizeQuality(qualityValue));
                console.log(`Quality changed to: ${selected}`);
            } catch (error) {
                console.error('Error changing quality:', error);
            }
        }

        // Show player information
        function showInfo() {
            const currentQuality = normalizeQuality(player.getCurrentQuality?.());
            const qualities = player.getQualityLevels ? player.getQualityLevels() : [];
            const currentSpeed = player.getPlaybackRate ? (player.getPlaybackRate() || 1) : 1;
            const position = player.getPosition ? player.getPosition() : 0;
            const duration = player.getDuration ? player.getDuration() : 0;
            const volume = player.getVolume ? player.getVolume() : 0;

            const info = `
Player Information:
-------------------
Position: ${Math.floor(position)}s / ${Math.floor(duration)}s
Playback Speed: ${currentSpeed}x
Volume: ${volume}%
Current Quality: ${currentQuality === AUTO_QUALITY ? 'Auto' : (qualities[currentQuality]?.label || 'N/A')}
Available Qualities: ${qualities.map(q => q.label).join(', ')}
            `;

            alert(info);
            console.log(info);
        }

        // Kick things off
        initPlayer();
    </script>
</body>
</html>
